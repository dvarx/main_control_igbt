/*
 * uart_comm.c
 *
 *  Created on: Mar 4, 2021
 *      Author: dvarx
 */

#include "uart_comm.h"
#include <stdbool.h>
#include <stdint.h>

bool command_to_be_processed;
char input_buffer[128];
uint8_t input_pointer=0;

//uart related parameters
//parameters can be calculated for f(SMCLK)=48MHz at
//http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430BaudRateConverter/index.html
const eUSCI_UART_ConfigV1 uartConfig =
{
        EUSCI_A_UART_CLOCKSOURCE_SMCLK,          // SMCLK Clock Source
        6,                                     // BRDIV = 78
        8,                                       // UCxBRF = 2
        32,                                       // UCxBRS = 0
        EUSCI_A_UART_NO_PARITY,                  // No Parity
        EUSCI_A_UART_LSB_FIRST,                  // LSB First
        EUSCI_A_UART_ONE_STOP_BIT,               // One stop bit
        EUSCI_A_UART_MODE,                       // UART mode
        EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION,  // Oversampling
        EUSCI_A_UART_8_BIT_LEN                  // 8 bit data length
};

void init_uart(){
    /* Selecting P1.2 and P1.3 in UART mode */
    MAP_GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1,
            GPIO_PIN2 | GPIO_PIN3, GPIO_PRIMARY_MODULE_FUNCTION);

    /* Configuring UART Module */
    MAP_UART_initModule(EUSCI_A0_BASE, &uartConfig);
    UART_registerInterrupt(EUSCI_A0_BASE,uart_interrupt_handler);

    /* Enable UART module */
    MAP_UART_enableModule(EUSCI_A0_BASE);

    /* Enabling interrupts */
    MAP_UART_enableInterrupt(EUSCI_A0_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);
    MAP_Interrupt_enableInterrupt(INT_EUSCIA0);
    MAP_Interrupt_enableMaster();
}

void uart_interrupt_handler(void)
{
    //get the interrupt status of the eUSCI
    uint32_t status = MAP_UART_getEnabledInterruptStatus(EUSCI_A0_BASE);

    //check if the interrupt was generated by the UART interface, not SPI
    if(status & EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG)
    {
        //MAP_UART_transmitData(EUSCI_A0_BASE, MAP_UART_receiveData(EUSCI_A0_BASE));
        input_buffer[input_pointer]=MAP_UART_receiveData(EUSCI_A0_BASE);
        //check if newline character received. each command ends with a newline character
        //we replace the newline character with a string termination character for further processing
        if(input_buffer[input_pointer]=='\r'){
            command_to_be_processed=true;
            input_buffer[input_pointer]='\0';
            input_pointer=0;
        }
        else
            input_pointer++;
    }

}
